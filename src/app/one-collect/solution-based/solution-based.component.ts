import { takeUntil } from 'rxjs/operators';
import { Component, OnInit, OnDestroy } from '@angular/core';
import { Router, ActivatedRoute } from '@angular/router';
import { ApiService } from 'src/app/services/api/api.service';
import { DataService } from 'src/app/services/data/data.service';
import { HelperService } from 'src/app/services/helper/helper.service';
import { Subject, Subscription } from 'rxjs';

import * as _ from 'lodash';
declare var $: any;

import { environment } from 'src/environments/environment';
import { TranslateService } from '../../services/translate/translate.service';

@Component({
  selector: 'oc-solution-based',
  templateUrl: './solution-based.component.html',
  styleUrls: ['./solution-based.component.css']
})
export class SolutionBasedComponent implements OnInit, OnDestroy {
  inProfiles: any[] = [];
  inSubProfiles: any[] = [];
  inPersonas: any[] = [];

  outProfile: any;
  outSubProfile: any;
  outPersona: any;

  profileDetails: any;
  headers: any[] = [];
  components: any;
  componentsByKey: any;

  nextIds: any[] = [];
  inExtraFields: any[] = [];
  outExtraFields: any[] = [];
  serialPorts: any[] = [];

  // properties for auto-generate profiles
  // this will be commonly even for set solutions
  // by assuming that 1 row is generated by default
  autoGenerate: boolean = false;
  autoKeys: any[] = [];
  autoComponents: any = {};
  autoSubjects: any = {};
  showSelect: any = {};

  // modal collect
  modalData: any = {};

  // modal commands
  modalCommands: any = {};
  modalItem: any = { title: '' };

  // properties for row-wise auto-validation
  currentComponentKey: any;
  currentIdx: any = -1;
  currentObj: any = { hostname: '', username: '', password: '' };

  // toggle show all messages
  showAll: boolean = false;

  // saved project
  savedProject: any;

  // property for ASUP upload
  enableASUP: boolean = false;
  settingsSubscription: Subscription;

  // property for update credentials
  distinctRows: any[] = [];

  caLaunch: boolean = environment.caLaunch;
  //For onecollect settings
  enableOneCollect: any = false;
  enableOneCollectSubscription: Subscription;

  objective: any;
  //Notification default data
  notification = {
    title: this.translate.instant('Error_title'),
    message: '',
    width: '300',
    color: 'red'
  };
  client: any = environment.client;

  constructor(
    private apiService: ApiService,
    private dataService: DataService,
    private helper: HelperService,
    private router: Router,
    private route: ActivatedRoute,
    public translate: TranslateService
  ) {
    const keyword = this.route.snapshot.paramMap.get('keyword');
    if (keyword) {
      this.objective = this.helper.getDefaultKey(keyword);
      this.objective.value = keyword;
    }
    // detect changes in settings model to reflect in enableASUP
    this.settingsSubscription = dataService.settingsChanged$.subscribe(
      preferences => {
        this.enableASUP = preferences['enableASUP'];
      }
    );
  }

  ngOnDestroy() {
    // unsubscribe from settings
    this.settingsSubscription.unsubscribe();
    if (this.caLaunch) {
      this.enableOneCollectSubscription.unsubscribe();
    }
  }

  ngOnInit() {
    if (this.caLaunch) {
      this.enableOneCollect = this.dataService.getEnableOneCollect();
      this.enableOneCollectSubscription = this.dataService.modalCustomOC$.subscribe(
        ocvalue => {
          this.enableOneCollect = ocvalue;
          //Load default settings on change of onecollect options but not during edit
          let url = this.router.url;
          if (!(url.indexOf('/new-collection/solution-based?edit') >= 0)) {
            this.loadDefault();
          }
        }
      );
    }
    this.getAsupFromSettings();
    this.modalData.savedProject = false;
    this.modalData.schedule = null;
    this.modalData.collectionType = 'solution-based';
    this.savedProject = null;
    // check if component is loading from saved projects tab
    let jobName: string;
    this.route.queryParams.subscribe(params => {
      jobName = params['edit'];
    });
    if (jobName) {
      // fetch job from data service
      let job = this.dataService.getJob();
      // verify it is the same job stored in dataService
      if (job && job.name == jobName) {
        this.modalData.savedProject = true;
        // get schedule for the saved project, if any
        setTimeout(() => {
          this.dataService.setModalCollect(job);
        }, 0);
        // pre-populate component rows
        this.savedProject = job;
        this.populateComponents();
      } else {
        // load default view when jobName exists but there is a mismatch in dataService
        this.router.navigate(['/main/new-collection/solution-based/']);
        this.loadDefault();
      }
    } else {
      // load default view when there is no jobName
      this.loadDefault();
    }
  }

  getAsupFromSettings() {
    this.apiService.getPreferences().subscribe(data => {
      let preferences = data.preference;
      if (preferences) {
        preferences = JSON.parse(preferences)['basic'];
      } else {
        preferences = { enableASUP: true };
      }

      if (_.has(preferences, 'enableASUP')) {
        this.enableASUP = preferences.enableASUP;
      } else {
        this.enableASUP = true;
      }
    });
  }

  loadDefault() {
    // fetch profiles
    let caProfiles: any = [];
    this.apiService.getProfiles().subscribe(profiles => {
      this.inProfiles = profiles;
      if (this.caLaunch && !this.enableOneCollect) {
        _.forEach(this.inProfiles, (profile, i) => {
          if (profile.title != 'NetApp-HCI' && profile.title != 'FlexPod') {
            caProfiles.push(profile);
          }
        });
        this.inProfiles = caProfiles;
      }
      this.outProfile = profiles[0];
      // fetch subprofiles for first item in profiles
      this.changeProfile(profiles[0]);
    });
  }

  // method for pre-populating rows when loading a saved project
  populateComponents() {
    // fetch profiles
    this.apiService.getProfiles().subscribe(profiles => {
      this.inProfiles = profiles;
      this.outProfile = profiles[0];
      // pre-select profile
      let fields = this.savedProject.profile.split('::');
      let profileId = fields[0].split(':')[1];
      let idx = 0;
      _.forEach(this.inProfiles, (profile, i) => {
        if (profile['profile_id'] == profileId) {
          idx = i;
        }
      });
      this.outProfile = profiles[idx];
      this.changeProfile(profiles[idx]);
    });
  }

  // make associated changes for profile model change
  // savedProject is used to load pre-populated values
  changeProfile(profile) {
    let profileId = profile['profile_id'];
    let fields: any;
    let subProfileId: any;
    if (this.savedProject) {
      fields = this.savedProject.profile.split('::');
      subProfileId = fields[1].split(':')[1];
    }
    // get subprofiles from api
    this.apiService.getSubProfiles(profileId).subscribe(subProfiles => {
      this.inSubProfiles = subProfiles;
      let idx = 0;
      _.forEach(this.inSubProfiles, (subProfile, i) => {
        if (subProfile['subprofile_id'] == subProfileId) {
          idx = i;
        }
      });
      this.outSubProfile = subProfiles[idx];
      // get profile details from api
      this.apiService.getProfileDetails(profileId).subscribe(profileDetails => {
        this.profileDetails = profileDetails;
        this.changeSubProfile();
      });
    });
  }

  changeSubProfile() {
    let extras: any[] = [];
    if (this.savedProject) {
      let fields = this.savedProject.profile.split('::');
      if (fields.length > 2) {
        extras = fields.slice(2);
      }
    }
    // change personas
    this.setPersonas();
    // remove all extra fields after present extra field
    this.inExtraFields.length = 0;
    this.outExtraFields.length = 0;
    // add first extra field if any
    let nextId = this.outSubProfile['next_id'];
    this.addExtraField(nextId, extras);
  }

  changeExtraField(event, eIdx) {
    // remove all extra fields after present extra field
    this.inExtraFields.length = eIdx + 1;
    this.outExtraFields.length = eIdx + 1;
    // add new extra fields associated with new selected option
    let nextId = this.outExtraFields[eIdx]['next_id'];
    this.addExtraField(nextId);
  }

  addExtraField(nextId, extras?) {
    let subprofileId = this.outSubProfile['subprofile_id'];
    let extraId = null;
    let extraTitle = '';
    if (extras && extras.length) {
      let arrExtra = extras[0].split(':');
      extraId = arrExtra[1];
      extraTitle = arrExtra[2];
      // remove first element for passing to next addExtraField call
      extras.shift();
    }
    // check if nextId leads to an extra field
    if (_.has(this.profileDetails['subtypes'][subprofileId]['Items'], nextId)) {
      let items = this.profileDetails['subtypes'][subprofileId]['Items'][
        nextId
      ];
      this.inExtraFields.push(items);
      // pre-select extraField if already provided via extraId
      let idx = 0;
      if (extraId) {
        _.forEach(items['Item_list'], (extraField, i) => {
          if (extraField['name'] == extraTitle) {
            idx = i;
            // break from loop
            return false;
          }
        });
      }
      let extraField = items['Item_list'][idx];
      this.outExtraFields.push(extraField);
      // process the new next_id
      nextId = extraField['next_id'];
      this.addExtraField(nextId, extras);
    } else {
      // nextId refers to a form so set form
      this.setProfileForm(nextId);
    }
  }

  setPersonas() {
    let caPersonas: any = [];
    let personaId: any;
    if (this.savedProject) {
      personaId = this.savedProject.persona;
    }
    let subprofileId = this.outSubProfile['subprofile_id'];
    let ids = this.profileDetails['subtypes'][subprofileId]['personas'];
    let personas = _.split(ids, ',');
    let match_personas = this.profileDetails['personas'];
    if (this.caLaunch && !this.enableOneCollect) {
      _.forEach(personas, (persona, i) => {
        if (persona == 6 || persona == 50) {
          caPersonas.push(persona);
        }
      });
      if (!caPersonas.includes('6')) {
        caPersonas.push(personas[0]);
      }
      personas = caPersonas;
    }
    // set personas dropdown array
    this.inPersonas = _.map(personas, id => {
      return { id: id, title: match_personas[id] };
    });
    // if personaId is supplied then search and set it
    let idx = 0;

    //Select Analysis as default persona
    //Added in CA
    if (this.caLaunch || this.client.features.purposeBasedCollection) {
      _.forEach(this.inPersonas, (persona, i) => {
        if (persona['title'] == 'Analysis') {
          idx = i;
          this.outPersona = persona;
        }
      });
    }
    _.forEach(this.inPersonas, (persona, i) => {
      if (persona['id'] == personaId) {
        idx = i;
      }
    });
    this.outPersona = this.inPersonas[idx];
  }

  setProfileForm(nextId) {
    let profileId = this.outProfile['profile_id'];
    let subProfileId = this.outSubProfile['subprofile_id'];
    this.apiService
      .getProfileForm(profileId, subProfileId, nextId)
      .subscribe(profileForm => {
        // reset autoGenerate to false
        this.autoGenerate = false;
        // enable auto generate if key is present
        if (_.has(this.profileDetails['forms'][nextId], 'auto_generate')) {
          this.autoGenerate =
            this.profileDetails['forms'][nextId]['auto_generate'] == 'true'
              ? true
              : false;
        }
        // parse components
        this.components = JSON.parse(profileForm.components);
        this.componentsByKey = this.getComponentsByKey(this.components);
        // add additional keys for auto_generated forms
        _.forEach(this.components, (component, i) => {
          // add visibility of select box for profiles
          this.showSelect[component.id] = false;
          if (this.autoGenerate) {
            // insert dropdown_options array
            component['dropdown_arr'] = component['dropdown_options'].split(
              ','
            );
            component['dropdown_value'] = component['dropdown_arr'][0];
          } else {
            // for normal profiles there is only one option
            component['dropdown_arr'] = [1];
            component['dropdown_value'] = component['dropdown_arr'][0];
          }
        });
        // set headers
        this.setHeaders();
        this.setBody();
        this.setCommands();
        // main body will be processed once all async command loading is complete
        // see setCommands()
      });
    // init serial port for every form re-load since serial port
    // connectivity might happen by user while changing forms
    this.initSerialPorts();
  }

  /*********************************************/
  /* Method to initialize serial ports array on
  /* form reload
  /*********************************************/
  initSerialPorts() {
    this.apiService.getSerialPorts().subscribe(data => {
      this.serialPorts = data['list'];
    });
  }

  processMainBody() {
    this.setAutoGenerateBody();
    // update with saved project values if any
    if (this.savedProject) {
      this.updateSavedValues();
      this.updateSavedCommands();
      // set savedProject to null so that further changes
      // in dropdowns are reflected correctly
      this.savedProject = null;
    }
  }

  setHeaders() {
    let headers = [];
    let keys = [];
    _.forEach(this.components, (component, i) => {
      _.forEach(component.fields, (field, key) => {
        if (keys.indexOf(key) <= -1) {
          headers.push({
            key: key,
            order: field.order,
            tooltip: field.tooltip,
            type: field.type
          });
          keys.push(key);
        }
      });
      // add additional headers for mfa field
      if (_.has(component, 'enable_mfa') && component['enable_mfa'] == 'true') {
        if (keys.indexOf('enable_mfa') <= -1) {
          keys.push('enable_mfa');
          headers.push({
            key: 'enable_mfa',
            order: 10,
            tooltip: this.translate.instant('Enable MFA'),
            type: 'checkbox'
          });
          headers.push({
            key: 'mfa_key',
            order: 11,
            tooltip: this.translate.instant('SSH MFA Key Path'),
            type: 'text'
          });
        }
      }
    });
    this.headers = _.sortBy(headers, 'order');
  }

  setBody() {
    _.forEach(this.components, (component, i) => {
      // add additional proerties to component
      this.addComponentProperties(component);
    });
  }

  setCommands(update?) {
    /*
    _.forEach(this.components, (component, idx) => {
      let key = component.id;
      let type = this.outProfile["profile_id"];
      let commandset = component['commandset_id'];
      let persona = this.outPersona['id'];
      this.apiService.getCommands(type, commandset, persona).subscribe(commands => {
          // load all commands to the component
          _.forEach(commands['commands'], (command, i) => {
            component['commands'].push({command:command, selected:true});
          });
        });
    });
    */
    let components = this.components;
    let type = this.outProfile['profile_id'];
    let persona = this.outPersona['id'];
    this.apiService
      .getAllSolutionCommands(components, type, persona)
      .subscribe(commandsArr => {
        // loop through commands array
        _.forEach(commandsArr, (commands, componentIdx) => {
          // initiaize commands array
          this.components[componentIdx]['commands'] = [];
          // load all commands to the component
          _.forEach(commands['commands'], (command, i) => {
            this.components[componentIdx]['commands'].push({
              command: command['Command'],
              type: command['Type'],
              selected: true
            });
            // sort commands alphabetically
            this.components[componentIdx]['commands'] = _.sortBy(
              this.components[componentIdx]['commands'],
              'command'
            );
          });
        });
        // process main body only if this is not an update event
        if (!update) {
          // set main body after all async calls are processed
          this.processMainBody();
        } else {
          this.updateCommandsAutoComponents();
        }
      });
  }

  updateCommandsAutoComponents() {
    // reset ComponentsByKey to include new commands
    this.componentsByKey = this.getComponentsByKey(this.components);
    // update commands in autoComponents
    _.forEach(this.autoComponents, (components, componentKey) => {
      _.forEach(components, (component, i) => {
        component['commands'] = _.cloneDeep(
          this.componentsByKey[componentKey]['commands']
        );
      });
    });
  }

  setAutoGenerateBody() {
    // reset contents first
    this.resetAllComponents();
    // set subject for validating all rows
    this.autoSubjects['all'] = { all: new Subject<void>() };
    // dynamically generate rows for each component
    _.forEach(this.components, component => {
      let componentKey = component['id'];
      this.addNewComponentKey(componentKey);
      // generate components only when not loading from savedProject and autoGenerate
      if (!(this.savedProject && this.autoGenerate)) {
        this.generateComponents(componentKey);
      }
    });
  }

  addNewComponentKey(componentKey) {
    this.autoKeys.push(componentKey);
    this.autoComponents[componentKey] = [];
    this.autoSubjects[componentKey] = {};
    this.showSelect[componentKey] = false;
  }

  /*********************************************/
  /* Method to generate multiple rows for each
  /* componentKey
  /*********************************************/
  generateComponents(componentKey) {
    // close select box
    this.showSelect[componentKey] = false;
    // backup values from exisiting rows
    let backup = _.cloneDeep(this.autoComponents[componentKey]);
    // reset components for given componentKey
    this.resetComponentsByKey(componentKey);
    // get all components by key
    let components = this.componentsByKey;
    // cancel all previous requests associated with component
    _.forEach(this.autoSubjects[componentKey], (subject, key) => {
      subject.next();
    });
    // reset subjects for a given componentKey
    this.resetSubjectsByKey(componentKey);
    // dynamically add rows based on dropdown_value of base component
    for (let i = 0; i < components[componentKey]['dropdown_value']; i++) {
      this.addNewComponent(componentKey, i);
      // add back any old values
      if (i < backup.length) {
        this.autoComponents[componentKey][i] = _.cloneDeep(backup[i]);
      }
    }
  }

  addNewComponent(componentKey, idx) {
    let components = this.componentsByKey;
    // add subject by index for individually unsubscribing later
    this.autoSubjects[componentKey][idx] = new Subject<void>();
    // create new component row
    let component = _.cloneDeep(components[componentKey]);
    // add this to array
    this.autoComponents[componentKey].push(component);
  }

  addComponentProperties(component) {
    // add properties to component: validation, commands
    let validation = {
      validation: {
        show: false,
        loading: 'initial',
        model: '',
        os: '',
        host_name: '',
        report: ''
      }
    };
    _.assignIn(component, validation, { commands: [] });
    // add properties to fields: disabled, value
    let fields = component.fields;
    _.forEach(this.headers, (header, i) => {
      if (header.key != 'enable_mfa' && header.key != 'mfa_key') {
        if (_.has(fields, header.key)) {
          fields[header.key]['disabled'] = false;
          if (_.has(fields[header.key], 'default')) {
            fields[header.key]['value'] = fields[header.key]['default'];
          } else {
            fields[header.key]['value'] = '';
          }
          // check if type exists in the field object
          if (_.has(fields[header.key], 'type')) {
            // check if field type has text or password else default it to text
            if (
              fields[header.key]['type'] != 'text' &&
              fields[header.key]['type'] != 'password'
            ) {
              fields[header.key]['type'] = 'text';
            }
          } else {
            fields[header.key]['type'] = 'text';
          }
        } else {
          // set empty field when it is not there for the component
          fields[header.key] = { type: 'text', disabled: true, value: '' };
        }
      } else if (header.key == 'enable_mfa') {
        if (
          _.has(component, 'enable_mfa') &&
          component['enable_mfa'] == 'true'
        ) {
          fields['enable_mfa'] = {
            type: 'checkbox',
            disabled: false,
            value: false
          };
        } else {
          fields['enable_mfa'] = {
            type: 'checkbox',
            disabled: true,
            value: false
          };
        }
        fields['mfa_key'] = { type: 'text', disabled: true, value: '' };
      }
    });
  }

  getComponentsByKey(components) {
    let newComponents = {};
    _.forEach(components, (component, i) => {
      let key = component['id'];
      // make reference to object so that original object values get affected
      newComponents[key] = component;
    });
    return newComponents;
  }

  updateSavedValues() {
    // update values if loading from savedProject
    let savedComponents = JSON.parse(this.savedProject.components);
    // for autoGenerated components get count
    if (this.autoGenerate) {
      // get count of rows based on componentKey
      let keysCount = {};
      let keysSavedComponents = _.keys(savedComponents);
      _.forEach(keysSavedComponents, key => {
        let componentKey = key.replace(/-cid-.*/g, '');
        let idx = key.replace(/.*-cid-/g, '');
        if (!_.has(keysCount, componentKey)) {
          keysCount[componentKey] = 1;
        } else {
          keysCount[componentKey]++;
        }
      });

      // reset component dropdown_value
      _.forEach(keysCount, (count, componentKey) => {
        this.componentsByKey[componentKey]['dropdown_value'] = 0;
      });
      // load rows by count for componentKey
      _.forEach(keysCount, (count, componentKey) => {
        for (let i = 0; i < count; i++) {
          this.addNewComponent(componentKey, i);
          // update dropdown count
          this.componentsByKey[componentKey]['dropdown_value']++;
        }
      });
    }

    // update saved values
    _.forEach(savedComponents, (savedComponent, savedComponentKey) => {
      let componentKey = savedComponentKey;
      let idx = 0;
      // change indices for autoGenerated components
      if (this.autoGenerate) {
        // support old saved MCC project with one row per componentKey
        // check if number is present in key
        let number = savedComponentKey.replace(/[^0-9]+/g, '');
        if (number) {
          // changes indices only if multiple components are there for
          // same componentKey
          componentKey = savedComponentKey.replace(/-cid-.*/g, '');
          idx = savedComponentKey.replace(/.*-cid-/g, '');
        }
      }
      // check if componentKey exists in autoComponents
      if (!_.has(this.autoComponents, componentKey)) {
        this.addNewComponentKey(componentKey);
      }
      // check if index is available else create a new component
      if (idx >= this.autoComponents[componentKey].length) {
        this.addNewComponent(componentKey, idx);
        // update total count
        this.componentsByKey[componentKey]['dropdown_value']++;
      }
      let component = this.autoComponents[componentKey][idx];
      // continue to update saved values
      _.forEach(this.headers, (header, i) => {
        // if the savedComponent has a value associated with a field then update it
        if (_.has(component['fields'], header.key)) {
          component['fields'][header.key]['value'] = savedComponent[header.key];
        }
      });
      // override enable_mfa value to checked or unchecked
      if (_.find(this.headers, { key: 'enable_mfa' })) {
        if (
          _.has(savedComponent, 'mfa_enabled') &&
          savedComponent['mfa_enabled'] == 'true'
        ) {
          component['fields']['enable_mfa']['value'] = true;
        } else {
          component['fields']['enable_mfa']['value'] = false;
        }
      }
    });
  }

  updateSavedCommands() {
    let savedComponents = JSON.parse(this.savedProject.components);
    // update command checked state if loading from savedProject page
    _.forEach(savedComponents, (savedComponent, savedComponentKey) => {
      // get correct componentKey and idx
      let componentKey = savedComponentKey;
      let idx = 0;
      if (this.autoGenerate) {
        componentKey = savedComponentKey.replace(/-cid-.*/g, '');
        idx = savedComponentKey.replace(/.*-cid-/g, '');
      }
      // process saved commands
      if (_.has(savedComponent, 'commands')) {
        let savedCommands = savedComponent['commands'];
        if (savedCommands.length) {
          // first disable all commands
          _.forEach(
            this.autoComponents[componentKey][idx]['commands'],
            (commandObj, i) => {
              if (commandObj['type'] != 'substitution') {
                commandObj['selected'] = false;
              }
            }
          );
          // enable each command based on saved state
          _.forEach(savedCommands, (savedCommand, i) => {
            // find first match of command name in commands collection
            let commandObj = _.find(
              this.autoComponents[componentKey][idx]['commands'],
              commandObj => {
                return commandObj['command'] == savedCommand;
              }
            );
            // update selected state if there is a match
            if (commandObj) {
              commandObj['selected'] = true;
            }
          });
        }
      }
    });
  }

  resetAllComponents() {
    // empty keys
    this.autoKeys = [];
    // empty components
    _.forEach(this.autoComponents, (components, componentKey) => {
      delete this.autoComponents[componentKey];
    });
    // empty subjects
    this.autoComponents = {};
    _.forEach(this.autoSubjects, (subjects, componentKey) => {
      _.forEach(this.autoSubjects[componentKey], (subject, subjectKey) => {
        delete this.autoSubjects[componentKey][subjectKey];
      });
      delete this.autoSubjects[componentKey];
    });
    this.autoSubjects = {};
  }

  resetComponentsByKey(componentKey) {
    // empty components
    delete this.autoComponents[componentKey];
    this.autoComponents[componentKey] = [];
    // empty subjects
    _.forEach(this.autoSubjects[componentKey], (subject, subjectKey) => {
      delete this.autoSubjects[componentKey][subjectKey];
    });
    delete this.autoSubjects[componentKey];
    this.autoSubjects[componentKey] = {};
  }

  reset() {
    _.forEach(this.components, (component, i) => {
      // set number of components to default
      component['dropdown_value'] = component['dropdown_arr'][0];
      // generate default number of components again
      let componentKey = component['id'];
      this.generateComponents(componentKey);
    });
  }

  resetCommon(component) {
    // reset properties validation, commands
    let validation = {
      validation: {
        show: false,
        loading: 'initial',
        model: '',
        os: '',
        host_name: '',
        report: ''
      }
    };
    _.assignIn(component, validation);
    // enable all commands
    _.forEach(component.commands, (command, i) => {
      command.selected = true;
    });
    // set field values to default values
    _.forEach(this.headers, (header, i) => {
      if (_.has(component.fields[header.key], 'default')) {
        component.fields[header.key]['value'] =
          component.fields[header.key]['default'];
      } else {
        component.fields[header.key]['value'] = '';
      }
    });
  }

  resetSubjectsByKey(componentKey) {
    _.forEach(this.autoSubjects[componentKey], (subject, key) => {
      delete this.autoSubjects[componentKey][key];
    });
    this.autoSubjects[componentKey] = {};
  }

  changeInput(event, componentKey, idx) {
    let cComponentKey = this.currentComponentKey;
    let cIdx = this.currentIdx;
    // if user has not started inputting in any row then assign it current row
    if (cIdx == -1) {
      // set currentIdx and currentObj to present row
      this.setCurrentIdx(componentKey, idx);
    } else if (cComponentKey != componentKey || cIdx != idx) {
      // trigger validation when the row has changed
      // check if any value has changed in previous row
      if (
        this.autoComponents[cComponentKey][cIdx]['fields']['hostname'][
          'value'
        ] != '' &&
        this.autoComponents[cComponentKey][cIdx]['fields']['username'][
          'value'
        ] != '' &&
        this.autoComponents[cComponentKey][cIdx]['fields']['password'][
          'value'
        ] != '' &&
        (this.autoComponents[cComponentKey][cIdx]['fields']['hostname'][
          'value'
        ] != this.currentObj['hostname'] ||
          this.autoComponents[cComponentKey][cIdx]['fields']['username'][
            'value'
          ] != this.currentObj['username'] ||
          this.autoComponents[cComponentKey][cIdx]['fields']['password'][
            'value'
          ] != this.currentObj['password'])
      ) {
        // trigger row validation
        this.validateRow(cComponentKey, cIdx);
      }
      // set currentIdx and currentObj to present row whether irrespective of triggering validation
      this.setCurrentIdx(componentKey, idx);
    }
  }

  setCurrentIdx(componentKey, idx) {
    // set currentIdx and currentObj to present row
    this.currentComponentKey = componentKey;
    this.currentIdx = idx;
    this.currentObj['hostname'] = this.autoComponents[componentKey][idx][
      'fields'
    ]['hostname']['value'];
    this.currentObj['username'] = this.autoComponents[componentKey][idx][
      'fields'
    ]['username']['value'];
    this.currentObj['password'] = this.autoComponents[componentKey][idx][
      'fields'
    ]['password']['value'];
  }

  validate() {
    let profile = this.outProfile['profile_id'];
    let subProfile = this.outSubProfile['subprofile_id'];
    const obj = this.getObjString();
    if (!this.validateData(obj)) {
      this.helper.showModalPopup('#notification-modal');
      return;
    }
    // show loading spinner for all rows
    _.forEach(this.autoComponents, (components, componentKey) => {
      _.forEach(components, (component, i) => {
        component['validation']['loading'] = 'process';
      });
    });
    // cancel all previous subscriptions
    _.forEach(this.autoSubjects, (subjects, componentKey) => {
      _.forEach(subjects, (subject, idx) => {
        subject.next();
      });
    });
    // create a new subscription
    this.apiService
      .postProfileValidate(profile, subProfile, obj)
      .pipe(takeUntil(this.autoSubjects['all']['all']))
      .subscribe(data => {
        let responses = JSON.parse(data.validation_response);
        _.forEach(responses, (obj, key) => {
          let componentKey = key;
          let idx = 0;
          if (this.autoGenerate) {
            componentKey = key.replace(/-cid-.*/g, '');
            idx = key.replace(/.*-cid-/g, '');
          }
          this.autoComponents[componentKey][idx]['validation']['show'] = true;
          if (obj.status == 'Failed') {
            this.autoComponents[componentKey][idx]['validation']['status'] =
              'fail';
          } else {
            this.autoComponents[componentKey][idx]['validation']['status'] =
              'success';
          }
          this.autoComponents[componentKey][idx]['validation']['report'] =
            obj.report;
          this.autoComponents[componentKey][idx]['validation']['model'] =
            obj.model;
          this.autoComponents[componentKey][idx]['validation']['os'] = obj.os;
          this.autoComponents[componentKey][idx]['validation']['host_name'] =
            obj.host_name;
          this.autoComponents[componentKey][idx]['validation']['loading'] =
            'done';
        });
      });
  }

  /*********************************************************************
   * Should validate the hostname in two ways
   * 1. Required validation: At least one hostname should be there
   * 2. Duplicate validation: There should not be duplicate hostname
   * @param obj
   ********************************************************************/
  validateData(obj: string): boolean {
    const components = JSON.parse(obj)[0].Components;
    const arrComponents = _.toArray(components);

    //clear error message if any
    const keys = this.helper.getDynamicKeys(this.autoComponents);
    _.forEach(keys, k => {
      this.autoComponents[k][0].validation.username = false;
    });

    //check if all hostname empty
    if (this.helper.existsInAll(arrComponents, 'hostname', '')) {
      this.notification.message = this.translate.instant(
        'Hostname_error2_required'
      );
      return false;
    }

    //check if any duplicate hostname
    if (this.helper.hasDuplicate(arrComponents, 'hostname')) {
      this.notification.message = this.translate.instant('Duplicate_host');
      return false;
    }
    //components whose hostname is present but username doesnot
    const comps = _.filter(
      arrComponents,
      c => c.hostname != '' && c.username == ''
    );
    if (comps.length) {
      this.notification.message = this.translate.instant(
        'Username_error_required'
      );
      _.forEach(comps, c => {
        this.autoComponents[c.cid][0].validation.username = true;
      });
      return false;
    }

    //component.fields[header.key].value
    return true;
  }

  validateRow(componentKey, idx) {
    let profile = this.outProfile['profile_id'];
    let subProfile = this.outSubProfile['subprofile_id'];
    let obj = this.getObjString(componentKey, idx);
    this.autoComponents[componentKey][idx]['validation']['loading'] = 'process';
    // cancel any previous subscription for the row
    this.autoSubjects[componentKey][idx].next();
    // create a new subscription
    this.apiService
      .postProfileValidate(profile, subProfile, obj)
      .pipe(takeUntil(this.autoSubjects[componentKey][idx]))
      .subscribe(data => {
        let responses = JSON.parse(data.validation_response);
        _.forEach(responses, (obj, key) => {
          let componentKey = key;
          let idx = 0;
          if (this.autoGenerate) {
            componentKey = key.replace(/-cid-.*/g, '');
            idx = key.replace(/.*-cid-/g, '');
          }
          if (obj.status == 'Failed') {
            this.autoComponents[componentKey][idx]['validation']['status'] =
              'fail';
          } else {
            this.autoComponents[componentKey][idx]['validation']['status'] =
              'success';
          }
          this.autoComponents[componentKey][idx]['validation']['report'] =
            obj.report;
          this.autoComponents[componentKey][idx]['validation']['model'] =
            obj.model;
          this.autoComponents[componentKey][idx]['validation']['os'] = obj.os;
          this.autoComponents[componentKey][idx]['validation']['host_name'] =
            obj.host_name;
          this.autoComponents[componentKey][idx]['validation']['loading'] =
            'done';
        });
      });
    this.dataService.hideLoader();
  }

  toggleSelectBox(componentKey) {
    let initialState = this.showSelect[componentKey];
    _.forEach(this.showSelect, (value, key) => {
      this.showSelect[key] = false;
    });
    this.showSelect[componentKey] = !initialState;
  }

  setCommandsModal(componentKey, idx) {
    this.modalCommands = this.autoComponents[componentKey][idx]['commands'];
    this.modalItem = this.autoComponents[componentKey][idx];
  }

  viewMessages() {
    this.changeMessagesState(true);
  }

  hideMessages() {
    this.changeMessagesState(false);
  }

  changeMessagesState(state) {
    this.showAll = state;
    _.forEach(this.autoComponents, (components, componentKey) => {
      _.forEach(components, (component, i) => {
        component.validation.show = state;
      });
    });
  }

  viewMessage(componentKey, idx) {
    this.autoComponents[componentKey][idx].validation.show = true;
  }

  hideMessage(componentKey, idx) {
    this.autoComponents[componentKey][idx].validation.show = false;
  }

  private getObjString(componentKey = 'all', idx?) {
    let obj: any;
    if (componentKey == 'all') {
      obj = this.getObj();
    } else {
      obj = this.getObj(componentKey, idx);
    }
    return JSON.stringify([obj]);
  }

  private getObj(componentKey = 'all', idx?) {
    let obj = {};
    obj['persona_id'] = this.outPersona['id'];
    // build items property based on extra fields
    let items = '';
    _.forEach(this.outExtraFields, (field, i) => {
      items +=
        this.inExtraFields[i]['title'] +
        ':' +
        field['next_id'] +
        ':' +
        field['name'] +
        '::';
    });
    // remove trailing ::
    items = items.replace(/\:+$/, '');
    obj['items'] = items;
    // include form_id property
    if (this.outExtraFields.length) {
      let lastIdx = this.outExtraFields.length - 1;
      obj['form_id'] = this.outExtraFields[lastIdx]['next_id'];
    } else {
      obj['form_id'] = this.outSubProfile['next_id'];
    }
    // add components
    obj['Components'] = {};
    if (componentKey == 'all') {
      // process of all rows
      _.forEach(this.autoComponents, (components, componentKey) => {
        _.forEach(components, (component, i) => {
          let id = component['component_id'];
          if (this.autoGenerate) {
            id = component['component_id'] + '-cid-' + i;
          }
          obj['Components'][id] = _.assignIn({}, this.addObj(component));
          // add an index to retrieve validation results in order
          obj['Components'][id]['component_index'] = i;
        });
      });
    } else {
      // process for selected row
      let component = this.autoComponents[componentKey][idx];
      let id = component['component_id'];
      if (this.autoGenerate) {
        id = component['component_id'] + '-cid-' + idx;
      }
      obj['Components'][id] = _.assignIn({}, this.addObj(component));
      // add an index to retrieve validation results in order
      obj['Components'][id]['component_index'] = idx;
    }
    return obj;
  }

  private addObj(component) {
    let helper = this.helper;
    let obj = {
      category: component['category'],
      title: component['title'],
      cid: component['component_id'],
      model: component['validation']['model'],
      os: component['validation']['os'],
      host_name: component['validation']['host_name']
    };
    _.forEach(component['fields'], (field, key) => {
      obj[key] = helper.trim(field.value);
    });
    // add mfa field
    if (_.has(component['fields'], 'enable_mfa')) {
      obj['enable_mfa'] = true;
      if (component['fields']['enable_mfa']['value'] === true) {
        obj['mfa_enabled'] = true;
      } else {
        obj['mfa_enabled'] = false;
      }
    } else {
      obj['enable_mfa'] = false;
      obj['mfa_enabled'] = false;
      obj['mfa_key'] = '';
    }
    return obj;
  }

  private getCommandsObj() {
    let obj = {};
    obj['commandList'] = {};
    _.forEach(this.autoComponents, (components, componentKey) => {
      _.forEach(components, (component, i) => {
        let id = componentKey;
        if (this.autoGenerate) {
          id = component['component_id'] + '-cid-' + i;
        }
        let commands = component['commands'];
        obj['commandList'][id] = [];
        _.forEach(component['commands'], (commandObj, j) => {
          if (commandObj['selected']) {
            obj['commandList'][id].push({
              command: commandObj['command'],
              selected: 'true'
            });
          } else {
            obj['commandList'][id].push({
              command: commandObj['command'],
              selected: 'false'
            });
          }
        });
      });
    });
    return obj;
  }

  setObj() {
    this.modalData.obj = this.getObj();
    let userData = this.dataService.getUserData();
    _.assignIn(this.modalData.obj, this.getCommandsObj(), userData);
    this.modalData.profileId = this.outProfile.profile_id;
    this.modalData.subProfileId = this.outSubProfile.subprofile_id;
  }

  doSaveCollect = () => {
    this.setObj();
    $('#collect-modal').modal({
      backdrop: 'static',
      keyboard: false
    });
  };

  checkLiveStatus(callback) {
    if (!this.validateData(this.getObjString())) {
      this.helper.showModalPopup('#notification-modal');
      return;
    }
    if (!this.caLaunch) {
      // check if enableASUP is checked in settings
      // let profile = this.outProfile['profile_id'];
      if (this.enableASUP) {
        // check if user object is available in browser
        if (this.dataService.getUserData()) {
          // continue next level check if api server has session for user
          this.apiService.getLiveStatus().subscribe(response => {
            if (response.status == 200) {
              // process request for search data
              callback();
            } else {
              this.helper.showModalPopup('#sso-modal');
            }
          });
        } else {
          this.helper.showModalPopup('#sso-modal');
        }
      } else {
        this.doSaveCollect();
      }
    } else {
      let profile = this.outProfile['profile_id'];
      if (this.enableASUP) {
        // check if user object is available in browser
        if (this.dataService.getUserData()) {
          // continue next level check if api server has session for user
          this.apiService.getLiveStatus().subscribe(response => {
            if (response.status == 200) {
              // process request for search data
              this.doSaveCollect();
            } else {
              if (profile == 'Snap') {
                this.helper.showModalPopup('#sso-modal');
              } else {
                this.doSaveCollect();
              }
            }
          });
        } else {
          if (profile == 'Snap') {
            this.helper.showModalPopup('#sso-modal');
          } else {
            this.doSaveCollect();
          }
        }
      } else {
        this.doSaveCollect();
      }
    }
  }

  getDistinctRows() {
    let outputObjs = [];
    let categories = [];
    _.forEach(this.autoComponents, (autoComponentArr, autoKey) => {
      // check if components exist
      if (autoComponentArr.length) {
        let component = autoComponentArr[0];
        let category = component['category'];
        if (categories.indexOf(category) == -1) {
          // add category to array
          categories.push(category);
          // add new object
          let obj = {};
          obj['selected'] = false;
          obj['category'] = category;
          obj['autoKey'] = autoKey;
          _.forEach(component.fields, (fieldObj, field) => {
            obj[field] = _.cloneDeep(fieldObj);
            obj[field]['value'] = '';
          });
          outputObjs.push(obj);
        }
      }
    });
    this.distinctRows = outputObjs;
    this.helper.showModalPopup('#modal-update-credentials');
  }

  doUpdate(distinctRows) {
    // loop through distinct rows that are selected for update
    _.forEach(distinctRows, distinctObj => {
      // for case when autoGenerate is false
      if (!this.autoGenerate) {
        let components = _.filter(
          this.autoComponents,
          (autoComponentArr, autoKey) => {
            return autoComponentArr[0]['category'] == distinctObj['category'];
          }
        );
        _.forEach(components, (componentArr, i) => {
          let component = componentArr[0];
          // change value of fields
          _.forEach(this.headers, header => {
            // change only if the field is not blank
            if (distinctObj[header.key]['value'] != '') {
              component['fields'][header.key]['value'] =
                distinctObj[header.key]['value'];
            }
          });
        });
      }
      // for case when autoGenerate is true
      if (this.autoGenerate) {
        let autoKey = distinctObj['autoKey'];
        let components = this.autoComponents[autoKey];
        _.forEach(components, (component, i) => {
          // change value of fields
          _.forEach(this.headers, header => {
            // change only if the field is not blank
            if (distinctObj[header.key]['value'] != '') {
              component['fields'][header.key]['value'] =
                distinctObj[header.key]['value'];
            }
          });
        });
      }
    });
  }

  /*********************************************/
  /* Method to select private key
  /*********************************************/
  addPKFile(componentKey, idx) {
    let component = this.autoComponents[componentKey][idx];
    // initiate native file explorer open
    $('#key-' + componentKey + '-' + idx).click();
    $('#key-' + componentKey + '-' + idx).change(event => {
      let size = event.target.files['0'].size || null;
      if (size && size < 3000) {
        let reader = new FileReader();
        reader.onload = e => {
          let keyLower = reader.result.toString().toLowerCase();
          if (keyLower.includes('rsa private key')) {
            component.fields.privatekey.value = reader.result;
            component.fields.privatekeyError = false;
          } else {
            component.fields.privatekey.value = '';
            component.fields.privatekeyError = true;
          }
        };
        reader.readAsText(event.target.files['0']);
      } else {
        component.fields.privatekey.value = '';
        component.fields.privatekeyError = true;
      }
    });
  }

  removePKFile(componentKey, idx) {
    let component = this.autoComponents[componentKey][idx];
    $('#key-' + componentKey + '-' + idx).val('');
    component.fields.privatekey.value = '';
    component.fields.privatekeyError = false;
  }
}
